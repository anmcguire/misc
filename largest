#!/usr/bin/env python3

import math
import zlib
import os.path
import argparse


def main(args: argparse.Namespace) -> None:
    sizes = []
    base = args.directory

    for root, dirs, files in os.walk(base, topdown=True):
        if args.xdev and os.lstat(root).st_dev != os.lstat(base).st_dev:
            continue
        for branch in sorted(dirs + files):
            path = os.path.join(root, branch)
            path = os.path.expanduser(path)
            if os.path.exists(path):
                size = os.lstat(path).st_size
                sizes.append((size, path))

    sizes.sort(key=lambda t: t[0])

    n = -1 * args.number
    for t in reversed(sizes[n::]):
        size = readable(t[0]) if args.readable else t[0]
        path = t[1]
        if args.crc32:
            print(f'{size:>16}\t{crc32(path)}\t{path}')
        else:
            print(f'{size:>16}\t{path}')


def positive(n: str) -> int:
    n = int(n)
    if n < 1:
        raise argparse.ArgumentTypeError(f'{n} is not a positive integer')
    return n


def readable(n: int) -> str:
    suffixes = [
        'B', 'KiB', 'MiB', 'GiB',
        'TiB', 'PiB', 'EiB', 'ZiB',
        'YiB', 'RiB', 'QiB'
    ]

    x = int(math.log(n, 1024))
    return str(round(n / 1024 ** x, 2)) + suffixes[x] if x > 0 else str(n)


def get_options() -> argparse.Namespace:
    parser = argparse.ArgumentParser(
             description='Display largest files beneath directory')
    parser.add_argument('directory', help='top-level directory to traverse')
    parser.add_argument('-c', '--crc32', action='store_true',
                        help='compute crc32 for results; this may be slow')
    parser.add_argument('-x', '--xdev', action='store_true',
                        help='do not cross device boundaries')
    parser.add_argument('-n', '--number', type=positive, default=10,
                        help='number of files to display (default = 10)')
    parser.add_argument('-r', '--readable', action='store_true',
                        help='print file sizes in human-readable format')
    return parser.parse_args()


def crc32(file: str, size: int = 65536) -> str:
    with open(file, 'rb') as fh:
        crc = 0
        while True:
            data = fh.read(size)
            if not data:
                break
            crc = zlib.crc32(data, crc)
        return f'{crc:08x}'


if __name__ == '__main__':
    main(get_options())
