#!/usr/bin/env python3
"""
Identify files that are disk hogs beneath some directory,
and print a report on them. Optionally, compute a CRC32 on
those files to assist in spotting duplicates.
"""
import math
import zlib
import os.path
import argparse


def main(args: argparse.Namespace) -> None:
    """
    Walk the specified directory, collect values for file sizes, then
    report on those that are largest up to some specified number.
    """
    sizes = []
    base = args.directory

    for root, dirs, files in os.walk(base, topdown=True):
        if args.xdev and os.lstat(root).st_dev != os.lstat(base).st_dev:
            continue
        for branch in sorted(dirs + files):
            path = os.path.join(root, branch)
            path = os.path.expanduser(path)
            if os.path.exists(path):
                size = os.lstat(path).st_size
                sizes.append((size, path))

    sizes.sort(key=lambda t: t[0])

    k = -1 * args.number
    for t in reversed(sizes[k::]):
        size = readable(t[0]) if args.readable else t[0]
        path = t[1]
        if args.crc32:
            print(f'{size:>16}\t{crc32(path)}\t{path}')
        else:
            print(f'{size:>16}\t{path}')


def positive(n: str) -> int:
    """
    Ensure that whatever value we're passed is a positive integer.
    """
    n = int(n)
    if n < 1:
        raise argparse.ArgumentTypeError(f'{n} is not a positive integer')
    return n


def readable(n: int) -> str:
    """
    High byte-counts are hard to parse visually, so we make things easier 
    with IEC 60027-2 A.2 suffixes, as with the 'df -h' command. This is
    overkill for sure.
    """
    suffixes = [
        'B',   'KiB', 'MiB', 'GiB',
        'TiB', 'PiB', 'EiB', 'ZiB',
        'YiB', 'RiB', 'QiB'
    ]

    x = int(math.log(n, 1024))
    return str(round(n / 1024 ** x, 2)) + suffixes[x] if x > 0 else str(n)


def parse_arguments() -> argparse.Namespace:
    """
    Parse command line arguments. This task can grow large, so we
    take it out of the main() function.
    """
    parser = argparse.ArgumentParser(
             description='Display largest files beneath directory')
    parser.add_argument('directory', help='top-level directory to traverse')
    parser.add_argument('-c', '--crc32', action='store_true',
                        help='compute crc32 for results; this may be slow')
    parser.add_argument('-x', '--xdev', action='store_true',
                        help='do not cross device boundaries')
    parser.add_argument('-n', '--number', type=positive, default=10,
                        help='number of files to display (default = 10)')
    parser.add_argument('-r', '--readable', action='store_true',
                        help='print file sizes in human-readable format')
    return parser.parse_args()


def crc32(file: str, size: int = 65536) -> str:
    """
    Compute the CRC32 value for a file. This exists to make it easier to 
    spot duplicates in output, if desired.
    """
    with open(file, 'rb') as fh:
        crc = 0
        while True:
            data = fh.read(size)
            if not data:
                break
            crc = zlib.crc32(data, crc)
        return f'{crc:08x}'


if __name__ == '__main__':
    main(parse_arguments())
